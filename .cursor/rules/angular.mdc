---
description: 'Angular (standalone) best practices — signals, reactive forms, Material, SCSS, feature structure'
globs:
  - 'apps/web/src/**/*.ts'
  - 'apps/web/src/**/*.html'
  - 'apps/web/src/**/*.scss'
  - '!apps/web/src/**/*.spec.ts'
alwaysApply: false
---

# Angular app conventions (Standalone, latest Angular)

## Architecture

- Use **standalone components only** (no NgModules).
- Use `provideRouter`, `provideHttpClient`, and other `provide*` APIs in the bootstrap file.
- Structure the app under `src/app` by **features**:
  - `features/<feature-name>/` for main screens & flows.
  - `shared/` for shared components, pipes, directives, models, and utilities.
- Each feature gets:
  - a main container component,
  - a dedicated service (feature-level business logic),
  - an optional routing file if it has child routes.
- Prefer a lightweight **feature store** per feature using:
  - readonly signals for UI,
  - writable signals for local state,
  - imperative methods for commands,
  - `linkedSignal()` or `toSignal()` to sync external Observables.

---

## Components & signals

### Preferred signal-based APIs

- Inputs:
  myInput = input<Type>();
  myRequired = input.required<Type>();

- Local component state:
  counter = signal<number>(0);

- Derived state:
  doubleCounter = computed(() => this.counter() \* 2);

- View queries:
  viewChild.required<ElementRef>();
  viewChildren<ElementRef>();

### General rules

- Avoid decorator-based `@Input()` and `@ViewChild()` in new code.
- Never store mutable state directly on `this`; always use signals.
- Keep derived state in `computed()` instead of recomputing manually.

---

## `effect()` vs `watch()`

### Use `watch()` (preferred) for simple side-effects:

- logging, analytics, localStorage, DOM access, router actions, external libs.

Example:
watch(this.selectedCase, value => console.log(value));

### Use `effect()` only when:

- multiple dependencies exist,
- you need automatic dependency tracking,
- logic is reactive.

Never use `effect()` to mirror signals or sync Observables/forms.

---

## linkedSignal (sync external sources)

### One-way:

const user = linkedSignal({
source: this.api.getUser(),
initialValue: null,
});

### Two-way with FormControl:

const name = linkedSignal({
source: control.valueChanges,
initialValue: '',
forward: value => control.setValue(value, { emitEvent: false }),
});

Prefer linkedSignal over:

- manual subscribe(),
- effect(() => signal.set(other())),
- repeated sync logic.

Use computed() instead if the value is purely derived.

---

## Templates & Control Flow

- Use new Angular control flow (`@if`, `@for`, `@switch`).
- Avoid legacy `*ngIf`, `*ngFor`, etc.
- Always use `track` for `@for`.

Example:
@for (item of items(); track item.id) {
<app-row [item]="item" />
}

---

## Forms (Reactive + Typed)

- Always use Reactive Forms with NonNullableFormBuilder.
- Avoid template-driven forms (`ngModel`).
- Use typed FormGroup, FormControl, FormArray.
- Sync forms with signals using linkedSignal().

---

## Angular Material

- Centralize Material imports in `shared/material.imports.ts`.
- Import in components via `imports: [MATERIAL_IMPORTS, ...]`.
- Use ARIA labels, focus handling, proper tab order.

---

## Styling — SCSS, Flex, Responsive

- Use SCSS.
- Use CSS Flexbox
- Global styles in `src/styles.scss`.
- Feature styles placed next to component files.
- Prefer Flex/Grid layouts.
- Avoid deep selectors.
- Use layout wrappers.

---

## HTTP & Services

- Use HttpClient with strong typing.
- Feature-level services only.
- Convert Observables → signals only in store/service layer via linkedSignal or toSignal.
- Use interceptors for global errors.

---

## Testing

- Use Jest or Jasmine.
- Keep tests focused: inputs/outputs, rendering, computed logic.
- Test stores by reading signals after public method calls.
- Avoid testing effect()/watch() internals.

---
